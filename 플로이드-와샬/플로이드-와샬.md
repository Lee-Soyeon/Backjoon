# 플로이드-와샬(Floyd-Warshall) 알고리즘

## 변수

<img width="233" alt="스크린샷 2021-04-18 오후 4 31 47" src="https://user-images.githubusercontent.com/39182235/115137903-b7282500-a063-11eb-9968-528c6bfd3330.png">

* **정의** : 정점 집합 [1, 2, ..., k]에 속하는 정점들만 중간 정점으로 거쳐서 i에서 j에 이르는 최단 거리
* 사용한 정점의 **집합**과 관계지어 변수를 정의함

## 관계식

<img width="1003" alt="스크린샷 2021-04-18 오후 4 56 13" src="https://user-images.githubusercontent.com/39182235/115138420-0459c600-a067-11eb-9dfc-722dce0f24f7.png">

### 논리적 근거

<img width="30" alt="스크린샷 2021-04-18 오후 4 31 47" src="https://user-images.githubusercontent.com/39182235/115137903-b7282500-a063-11eb-9968-528c6bfd3330.png">는 정의에 따라 정점 집합 {1, 2, ..., k}에 속하는 정점만을 거쳐서 i에서 j에 이르는 최단 거리다.

경로 p를 이런 최단 경로라고 하자.

<img width="875" alt="스크린샷 2021-04-18 오후 5 02 32" src="https://user-images.githubusercontent.com/39182235/115138552-e476d200-a067-11eb-97de-774b6eccd87d.png">

#### 1
```
경로 p에 정점 k가 포함되어 있다면 정점 k를 중심으로 경로 i ~ k와 경로 k ~ j로 나누고 위 그림의 윗 경로가 이 상황을 나타낸다. 

최단 경로상에 사이클은 존재할 수 없으므로 두 경로의 중간에 정점 k는 더 이상 나타나지 않는다. 

즉, 이 두 경로는 각각 정점 집합 {1, 2, ..., k - 1}에 속하는 정점만을 거치는 최단 경로 i ~ k와 정점 집합 {1, 2, ..., k - 1}에 속하는 정점만을 거치는 최단 경로 k ~ j가 된다.
```

#### 2
```
경로 p에 정점 k가 포함되어 있지 않으면 이 경로는 정점 집합 {1, 2, ..., k - 1}에 속하는 정점만을 사용한다. 

그림의 아랫 경로가 이 상황을 나타낸다.
```

즉, 경로 i ~ j를 위한 위의 두 경우 중 작은 것이 <img width="30" alt="스크린샷 2021-04-18 오후 4 31 47" src="https://user-images.githubusercontent.com/39182235/115137903-b7282500-a063-11eb-9968-528c6bfd3330.png">가 된다.

이것을 구현한 것이 플로이드-워샬 알고리즘이다.

여기서 1, 2, ..., n으로 매겨지는 정점의 순서는 어떠한 순서든 상관없고 한 가지 순서가 고정되기만 하면 된다.

## 코드

``` java
public static void floydWarshall() {
    // 기준이 되는 거쳐가는 노드 K
    for(int k = 1; k <= n; k++) {
        // 출발하는 노드 i
        for(int i = 1; i <= n; i++) {
            // 도착하는 노드 j
            for(int j = 1; j <= n; j++) {
                //i에서 k를 거쳤다가 k에서 j 까지 가는 거리와 i에서 j 까지 가는 거리를 비교해서 작은 값이 최소거리이다.
                arr[i][j] = Math.min(arr[i][k] + arr[k][j], arr[i][j]);
            }
        }
    }
}
```

## 시간복잡도

* 플로이드-와샬 알고리즘의 수행 시간은 Θ(N)의 for 루프가 세 겹 중첩되었고, 각 경우에 단 두 가지 경우의 대소를 비교하는 것이므로 상수 시간이 걸림 
* **Θ(N^3)**
